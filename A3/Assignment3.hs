{- 
 - CPSC 449 ASSIGNMENT THREE
 - 26/10/2014
 - Submitted by Michael Y. Hung  (UCID: 10099049) 
 -}
 
module Assignment3 where

import Prelude hiding (and)

 -- Problem 1 (a) --
 
 -- Data Type Poly for polynomial. Valid polynomials include constants, single variables, 
 -- sums, products, and powers. Coefficients are to be written as a Multiplication
 -- between a Constant and another Polynomial or Variable. Logarithms and divisions
 -- have not been considered.
data Poly = Variable Char | Constant Int | Add Poly Poly | Mult Poly Poly | Exp Poly Int

 -- Problem 1 (b) --

 -- A Poly type representation of the polynomial 1 + x + x^3
expr :: Poly
expr = Add (Add (Constant 1) (Variable 'x')) (Mult (Constant 3) (Exp (Variable 'x') 3))

 -- Problem 1 (c) --

 -- showPoly takes a polynomial and prints it out as a String in formal mathematical 
 -- syntax. Note that the result is unfactored and unsimplified. The String is 
 -- generated recursively.
showPoly :: Poly -> String
showPoly (Variable v) =  [v]
showPoly (Constant i) = show i
showPoly (Exp p1 i) = "((" ++ showPoly p1 ++ ") ^ " ++ show i ++ ")"
showPoly (Add p1 p2) = "(" ++ showPoly p1 ++ " + " ++ showPoly p2 ++ ")"
showPoly (Mult p1 p2) = "(" ++ showPoly p1 ++ " * " ++ showPoly p2 ++ ")"

 -- Problem 1 (d) --

 -- derivative takes a polynomial and returns its derivative as a polynomial.
 -- The derivative is calculated recursively. It does not account for derivatives
 -- of logarithms or fractions.
derivative :: Poly -> Poly
derivative (Variable _) = Constant 1
derivative (Constant _) = Constant 0
derivative (Exp p1 i) = Mult (Constant i) ( Mult (Exp p1 (i - 1)) (derivative p1))
derivative (Add p1 p2) = Add (derivative p1) (derivative p2)
derivative (Mult p1 p2) = Add (Mult p1 (derivative p2)) (Mult p2 (derivative p1))

 -- Problem 1 (e) and 2 on Assignment3.pdf --

 -- Problem 3 (a) --

 -- and takes a list of Boolean values and returns their And by using filter to 
 -- construct a list of all occurrences of False in xs, then using foldr to
 -- And them with True. In other words, if there is a False in xs at all, the
 -- resultant Boolean will be False. Otherwise, and will return True, even
 -- in the case of the empty list, [].
and :: [Bool] -> Bool
and xs = foldr (&&) True (filter (== False) xs)

 -- Problem 3 (b) --

 -- count takes some Integer predicate (such as even, odd, or > 3) and a list of Integers
 -- and returns the number of elements in that list that pass the predicate check. It simply
 -- takes the length of the list generated by filter, using the provided predicate.
count :: (Integer -> Bool) -> [Integer] -> Integer
count p xs = toInteger (length (filter p xs))

 -- Problem 4 (a) --
 
 -- iter takes an Integer n, an Integer function f, and an Integer constant x, and
 -- recursively applies the function f to x, f x, f ( f x), etc. n times. 
iter :: Integer -> (Integer -> Integer) -> Integer -> Integer
iter 0 _ x = x
iter n f x = f (iter (n - 1) f x)

 -- Problem 4 (b) --
 
 -- double takes and Integer and multiplies it by 2 - i.e. it doubles the Integer.
double :: Integer -> Integer
double n = 2*n

 -- twoExp raises 2 to some provided Integer n power.
twoExp :: Integer -> Integer
twoExp n = iter n double 1
 